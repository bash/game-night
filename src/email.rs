use anyhow::{anyhow, Context as _, Result};
use dyn_clone::DynClone;
use lettre::message::header::{Header, HeaderName, HeaderValue};
use lettre::message::{Mailbox, MultiPart, SinglePart};
use lettre::Message;
use rand::{distributions, thread_rng, Rng as _};
use rocket::async_trait;
use rocket::figment::value::magic::RelativePathBuf;
use rocket::figment::Figment;
use rocket::tokio::fs::{create_dir_all, read_to_string, rename, OpenOptions};
use rocket::tokio::io::AsyncWriteExt;
use rocket_dyn_templates::tera::{Context, Tera};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use uuid::Uuid;

const DEFAULT_EMAIL_TEMPLATE_DIR: &str = "emails";
const DEFAULT_OUTBOX_DIR: &str = "outbox";

#[async_trait]
pub(crate) trait EmailSender: Send + Sync + DynClone {
    async fn send(&self, recipient: Mailbox, email: &dyn EmailMessage) -> Result<()>;
}

dyn_clone::clone_trait_object!(EmailSender);

pub(crate) trait EmailMessage: Send + Sync + EmailMessageContext {
    fn subject(&self) -> String;

    fn template_name(&self) -> String;

    fn attachments(&self) -> Result<Vec<SinglePart>> {
        Ok(Vec::default())
    }
}

pub(crate) trait EmailMessageContext {
    fn template_context(&self) -> Result<Context>;
}

impl<T> EmailMessageContext for T
where
    T: Serialize,
{
    fn template_context(&self) -> Result<Context> {
        Context::from_serialize(self).map_err(Into::into)
    }
}

#[derive(Clone)]
pub(crate) struct EmailSenderImpl {
    sender: Mailbox,
    outbox_dir: PathBuf,
    css: String,
    tera: Tera,
}

#[async_trait]
impl EmailSender for EmailSenderImpl {
    async fn send(&self, recipient: Mailbox, email: &dyn EmailMessage) -> Result<()> {
        let multipart = email
            .attachments()?
            .into_iter()
            .fold(self.render_email_body(email)?, |m, s| m.singlepart(s));
        let message = Message::builder()
            .from(self.sender.clone())
            .to(recipient)
            .subject(email.subject())
            .header(AutoSubmitted::AutoGenerated)
            .header(XAutoResponseSuppress::All)
            .multipart(multipart)
            .context("failed to create email message")?;

        let message_id = Uuid::new_v4();

        create_dir_all(&self.outbox_dir).await?;

        // We don't want the outbox processor to attempt to send
        // files while we're writing them.
        // We use the leading _ to communicate that to the `outbox` program.
        let mut temporary_path = self.outbox_dir.clone();
        temporary_path.push(format!("_{}.eml", message_id));
        let mut file = OpenOptions::default()
            .create_new(true)
            .write(true)
            .open(&temporary_path)
            .await?;
        file.write_all(&message.formatted()).await?;

        // Renames are atomic, so the file is available `outbox` all at once.
        let mut message_path = self.outbox_dir.clone();
        message_path.push(format!("{}.eml", message_id));
        rename(temporary_path, &message_path).await?;

        #[cfg(debug_assertions)]
        opener::open(&message_path)?;

        Ok(())
    }
}

impl EmailSenderImpl {
    pub(crate) async fn from_figment(figment: &Figment) -> Result<Self> {
        let config: EmailSenderConfig = figment
            .extract_inner("email")
            .context("failed to read email sender configuration")?;
        let template_dir = config
            .template_dir
            .as_ref()
            .map(|t| t.relative())
            .unwrap_or_else(|| DEFAULT_EMAIL_TEMPLATE_DIR.into());
        let outbox_dir = config
            .outbox_dir
            .map(|d| d.relative())
            .unwrap_or_else(|| DEFAULT_OUTBOX_DIR.into());
        let mut css_file_path = template_dir.clone();
        css_file_path.push("email.css");

        Ok(Self {
            sender: config.sender,
            outbox_dir,
            tera: create_tera(&template_dir)?,
            css: read_to_string(css_file_path).await?,
        })
    }

    fn render_email_body(&self, email: &dyn EmailMessage) -> Result<MultiPart> {
        let template_name = email.template_name();
        let mut template_context = email.template_context()?;
        template_context.insert("greeting", get_random_greeting());
        template_context.insert("skin_tone", get_random_skin_tone_modifier());
        template_context.insert("heart", get_random_heart());
        template_context.insert("css", &self.css);
        let html_template_name = format!("{}.html.tera", &template_name);
        let text_template_name = format!("{}.txt.tera", &template_name);

        Ok(MultiPart::alternative_plain_html(
            self.tera
                .render(&text_template_name, &template_context)
                .context("failed to render tera template")?,
            self.tera
                .render(&html_template_name, &template_context)
                .context("failed to render tera template")?,
        ))
    }
}

fn create_tera(template_dir: &Path) -> Result<Tera> {
    let templates = template_dir.join("**.tera");
    let templates = templates
        .to_str()
        .context("template dir is not valid utf-8")?;
    let mut tera = Tera::new(templates).context("failed to initialize Tera")?;
    tera.build_inheritance_chains()
        .context("failed to build tera's inheritance chain")?;
    crate::template::register_custom_functions(&mut tera);
    Ok(tera)
}

fn get_random_greeting() -> &'static str {
    const GREETINGS: &[&str] = &[
        "Hi",
        "Ciao",
        "SalÃ¼",
        "Hola",
        "Hellooo",
        "Hey there",
        "Greetings galore",
        "Aloha",
        "Howdy",
        "Hiyaa",
        "Yoohoo~",
        "Ahoy",
    ];
    thread_rng().sample(distributions::Slice::new(GREETINGS).unwrap())
}

fn get_random_skin_tone_modifier() -> &'static str {
    const SKIN_TONE_MODIFIERS: &[&str] = &[
        "\u{1F3FB}",
        "\u{1F3FC}",
        "\u{1F3FD}",
        "\u{1F3FE}",
        "\u{1F3FF}",
        "",
    ];
    thread_rng().sample(distributions::Slice::new(SKIN_TONE_MODIFIERS).unwrap())
}

fn get_random_heart() -> &'static str {
    const HEARTS: &[&str] = &["â¤ï¸", "ğŸ’–", "ğŸ’™", "ğŸ©µ", "ğŸ’š", "ğŸ’›", "ğŸ’œ", "ğŸ©·", "ğŸ§¡"];
    thread_rng().sample(distributions::Slice::new(HEARTS).unwrap())
}

#[derive(Debug, Deserialize)]
struct EmailSenderConfig {
    sender: Mailbox,
    outbox_dir: Option<RelativePathBuf>,
    template_dir: Option<RelativePathBuf>,
}

#[derive(Debug, Copy, Clone)]
enum AutoSubmitted {
    /// Indicates that a message was generated by an automatic process, and is not a direct response to another message.
    /// Automatic responses should not be issued to messages with this header. See <https://www.rfc-editor.org/rfc/rfc3834#section-2>.
    AutoGenerated,
}

impl Header for AutoSubmitted {
    fn name() -> lettre::message::header::HeaderName {
        HeaderName::new_from_ascii_str("Auto-Submitted")
    }

    fn parse(_: &str) -> std::result::Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        Err(anyhow!("Not supported").into())
    }

    fn display(&self) -> lettre::message::header::HeaderValue {
        HeaderValue::new(
            Self::name(),
            match self {
                Self::AutoGenerated => "auto-generated".to_owned(),
            },
        )
    }
}

#[derive(Debug, Copy, Clone)]
enum XAutoResponseSuppress {
    /// Suppresses auto responses from Exchange.
    /// See <https://learn.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxcmail/e489ffaf-19ed-4285-96d9-c31c42cab17f> for details.
    All,
}

impl Header for XAutoResponseSuppress {
    fn name() -> lettre::message::header::HeaderName {
        HeaderName::new_from_ascii_str("X-Auto-Response-Suppress")
    }

    fn parse(_: &str) -> std::result::Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        Err(anyhow!("Not supported").into())
    }

    fn display(&self) -> lettre::message::header::HeaderValue {
        HeaderValue::new(
            Self::name(),
            match self {
                Self::All => "All".to_owned(),
            },
        )
    }
}
